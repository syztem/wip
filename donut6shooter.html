<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shooting Tower Arcade: Reborn</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        canvas { display: block; }
        #score { position: absolute; top: 20px; right: 20px; color: #0ff; font-family: monospace; font-size: 24px; }
        #weapon { position: absolute; bottom: 20px; left: 20px; color: #0ff; font-family: monospace; font-size: 18px; }
        #crosshair { position: absolute; top: 50%; left: 50%; width: 20px; height: 20px; background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20"><circle cx="10" cy="10" r="2" fill="cyan" /><line x1="10" y1="2" x2="10" y2="6" stroke="cyan" /><line x1="10" y1="14" x2="10" y2="18" stroke="cyan" /><line x1="2" y1="10" x2="6" y2="10" stroke="cyan" /><line x1="14" y1="10" x2="18" y2="10" stroke="cyan" /></svg>') no-repeat center; transform: translate(-50%, -50%); pointer-events: none; }
        #error { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: red; font-family: monospace; font-size: 20px; text-align: center; display: none; }
    </style>
</head>
<body>
    <div id="score">SCORE: 0</div>
    <div id="weapon">WEAPON: Pulse</div>
    <div id="crosshair"></div>
    <div id="error"></div>
    <script src="https://unpkg.com/three@0.168.0/build/three.min.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/ammo.js@0.0.10/builds/ammo.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/gsap@3.12.5/dist/gsap.min.js" crossorigin="anonymous"></script>
    <script>
        // Log CDN load status
        console.log('Checking libraries...');
        console.log('Three.js:', typeof THREE !== 'undefined' ? 'Loaded' : 'Failed');
        console.log('Ammo.js:', typeof Ammo !== 'undefined' ? 'Loaded' : 'Failed');
        console.log('GSAP:', typeof gsap !== 'undefined' ? 'Loaded' : 'Failed');

        // Check if libraries loaded
        if (typeof THREE === 'undefined') {
            showError('Three.js failed to load. Check network or try a different browser.');
            throw new Error('Three.js not loaded');
        }

        function showError(message) {
            const errorDiv = document.getElementById('error');
            errorDiv.style.display = 'block';
            errorDiv.textContent = message;
        }

        // Minimal fallback render if physics fails
        let scene, camera, renderer;
        function initFallback() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 10);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Add ground
            const groundGeo = new THREE.PlaneGeometry(100, 100);
            const groundMat = new THREE.MeshBasicMaterial({ color: 0x222222 });
            const groundMesh = new THREE.Mesh(groundGeo, groundMat);
            groundMesh.rotation.x = -Math.PI / 2;
            scene.add(groundMesh);

            // Add light
            scene.add(new THREE.AmbientLight(0x404040));

            function animateFallback() {
                requestAnimationFrame(animateFallback);
                renderer.render(scene, camera);
            }
            animateFallback();
        }

        // Proceed with full game if Ammo.js is available
        if (typeof Ammo !== 'undefined') {
            Ammo().then(function(AmmoLib) {
                Ammo = AmmoLib;
                console.log('Ammo.js initialized');

                // Core variables
                let world, player, objects = [];
                let score = 0, combo = 1, lastHitTime = 0, weapon = 'pulse';
                let moveTarget = null, isJumping = false;
                const moveSpeed = 8, jumpStrength = 5;

                init();

                function init() {
                    try {
                        // Scene setup
                        scene = new THREE.Scene();
                        scene.background = new THREE.Color(0x111111);

                        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                        camera.position.set(0, 2, 10);

                        renderer = new THREE.WebGLRenderer({ antialias: true });
                        renderer.setSize(window.innerWidth, window.innerHeight);
                        renderer.shadowMap.enabled = true;
                        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                        document.body.appendChild(renderer.domElement);

                        // Physics setup
                        const collisionConfig = new Ammo.btDefaultCollisionConfiguration();
                        const dispatcher = new Ammo.btCollisionDispatcher(collisionConfig);
                        const broadphase = new Ammo.btDbvtBroadphase();
                        const solver = new Ammo.btSequentialImpulseConstraintSolver();
                        world = new Ammo.btDiscreteDynamicsWorld(dispatcher, broadphase, solver, collisionConfig);
                        world.setGravity(new Ammo.btVector3(0, -9.82, 0));

                        // Player
                        const playerShape = new Ammo.btSphereShape(0.5);
                        const playerTransform = new Ammo.btTransform();
                        playerTransform.setIdentity();
                        playerTransform.setOrigin(new Ammo.btVector3(0, 2, 10));
                        const playerMotionState = new Ammo.btDefaultMotionState(playerTransform);
                        const playerInertia = new Ammo.btVector3(0, 0, 0);
                        playerShape.calculateLocalInertia(5, playerInertia);
                        const playerBody = new Ammo.btRigidBody(
                            new Ammo.btRigidBodyConstructionInfo(5, playerMotionState, playerShape, playerInertia)
                        );
                        playerBody.setDamping(0.9, 0.9);
                        world.addRigidBody(playerBody);
                        player = { body: playerBody, mesh: new THREE.Object3D() };
                        scene.add(player.mesh);

                        // Lights
                        scene.add(new THREE.AmbientLight(0x404040, 0.5));
                        const dirLight = new THREE.DirectionalLight(0x00aaff, 0.7);
                        dirLight.position.set(10, 20, -5);
                        dirLight.castShadow = true;
                        dirLight.shadow.mapSize.set(512, 512);
                        scene.add(dirLight);

                        // Ground
                        const groundGeo = new THREE.PlaneGeometry(100, 100);
                        const groundMat = new THREE.MeshStandardMaterial({ color: 0x222222 });
                        const groundMesh = new THREE.Mesh(groundGeo, groundMat);
                        groundMesh.rotation.x = -Math.PI / 2;
                        groundMesh.receiveShadow = true;
                        scene.add(groundMesh);
                        const groundShape = new Ammo.btStaticPlaneShape(new Ammo.btVector3(0, 1, 0), 0);
                        const groundTransform = new Ammo.btTransform();
                        groundTransform.setIdentity();
                        const groundMotionState = new Ammo.btDefaultMotionState(groundTransform);
                        const groundBody = new Ammo.btRigidBody(
                            new Ammo.btRigidBodyConstructionInfo(0, groundMotionState, groundShape)
                        );
                        world.addRigidBody(groundBody);

                        // Platforms and targets
                        spawnPlatforms();
                        spawnTarget();

                        // Events
                        window.addEventListener('resize', () => {
                            camera.aspect = window.innerWidth / window.innerHeight;
                            camera.updateProjectionMatrix();
                            renderer.setSize(window.innerWidth, window.innerHeight);
                        });
                        window.addEventListener('mousedown', handleMouseDown);
                        window.addEventListener('touchstart', handleTouchStart);
                        window.addEventListener('keydown', handleKeyDown);
                        window.addEventListener('mousemove', handleMouseMove);
                        window.addEventListener('contextmenu', (e) => e.preventDefault());

                        animate();
                    } catch (e) {
                        showError('Game initialization failed. Falling back to basic render.');
                        console.error('Init failed:', e);
                        initFallback();
                    }
                }

                function handleMouseDown(e) {
                    if (e.button === 0) shoot();
                    else if (e.button === 2) moveTarget = getGroundPoint(e);
                }

                function handleTouchStart(e) {
                    e.preventDefault();
                    if (e.touches.length === 1) shoot();
                    else if (e.touches.length === 2) moveTarget = getGroundPoint(e.touches[0]);
                }

                function handleKeyDown(e) {
                    if (e.code === 'Space' && !isJumping) {
                        player.body.setLinearVelocity(new Ammo.btVector3(0, jumpStrength, 0));
                        isJumping = true;
                    }
                    if (e.code === 'Digit1') { weapon = 'pulse'; updateWeapon(); }
                    if (e.code === 'Digit2') { weapon = 'void'; updateWeapon(); }
                    if (e.code === 'Digit3') { weapon = 'prism'; updateWeapon(); }
                }

                function handleMouseMove(e) {
                    const mouse = new THREE.Vector2(
                        (e.clientX / window.innerWidth) * 2 - 1,
                        -(e.clientY / window.innerHeight) * 2 + 1
                    );
                    const raycaster = new THREE.Raycaster();
                    raycaster.setFromCamera(mouse, camera);
                    camera.lookAt(raycaster.ray.direction.clone().multiplyScalar(100).add(camera.position));
                }

                function spawnPlatforms() {
                    for (let i = 0; i < 5; i++) {
                        const size = 5;
                        const geo = new THREE.PlaneGeometry(size, size);
                        const mat = new THREE.MeshStandardMaterial({ color: 0x00aaff, emissive: 0x005577 });
                        const mesh = new THREE.Mesh(geo, mat);
                        mesh.rotation.x = -Math.PI / 2;
                        mesh.position.set(
                            (Math.random() - 0.5) * 50,
                            Math.random() * 5 + 2,
                            (Math.random() - 0.5) * 50
                        );
                        mesh.castShadow = true;
                        scene.add(mesh);
                        const shape = new Ammo.btBoxShape(new Ammo.btVector3(size / 2, 0.1, size / 2));
                        const transform = new Ammo.btTransform();
                        transform.setIdentity();
                        transform.setOrigin(new Ammo.btVector3(mesh.position.x, mesh.position.y, mesh.position.z));
                        const body = new Ammo.btRigidBody(
                            new Ammo.btRigidBodyConstructionInfo(0, new Ammo.btDefaultMotionState(transform), shape)
                        );
                        world.addRigidBody(body);
                        objects.push({ mesh, body });
                    }
                }

                function spawnTarget() {
                    const geo = new THREE.IcosahedronGeometry(1, 0);
                    const mat = new THREE.MeshStandardMaterial({ color: 0xff00ff, emissive: 0x770077 });
                    const mesh = new THREE.Mesh(geo, mat);
                    mesh.position.set(
                        (Math.random() - 0.5) * 40,
                        Math.random() * 10 + 5,
                        (Math.random() - 0.5) * 40
                    );
                    mesh.castShadow = true;
                    scene.add(mesh);
                    const shape = new Ammo.btSphereShape(1);
                    const transform = new Ammo.btTransform();
                    transform.setIdentity();
                    transform.setOrigin(new Ammo.btVector3(mesh.position.x, mesh.position.y, mesh.position.z));
                    const body = new Ammo.btRigidBody(
                        new Ammo.btRigidBodyConstructionInfo(2, new Ammo.btDefaultMotionState(transform), shape)
                    );
                    body.setLinearVelocity(new Ammo.btVector3((Math.random() - 0.5) * 5, 0, (Math.random() - 0.5) * 5));
                    world.addRigidBody(body);
                    objects.push({ mesh, body, type: 'target' });
                    setTimeout(spawnTarget, 3000);
                }

                function shoot() {
                    let radius = 0.2, mass = 1, speed = 50, count = 1, color = 0xff4444, geoType = 'sphere';
                    if (weapon === 'void') {
                        radius = 0.5; mass = 5; speed = 30; color = 0x4444ff; geoType = 'box';
                    } else if (weapon === 'prism') {
                        radius = 0.1; mass = 0.5; count = 5; color = 0xffaa00; geoType = 'triangle';
                    }

                    for (let i = 0; i < count; i++) {
                        const geo = geoType === 'sphere' ? new THREE.SphereGeometry(radius, 16, 16) :
                                    geoType === 'box' ? new THREE.BoxGeometry(radius * 2, radius * 2, radius * 2) :
                                    new THREE.BufferGeometry().setFromPoints([
                                        new THREE.Vector3(0, radius, 0),
                                        new THREE.Vector3(-radius, -radius, 0),
                                        new THREE.Vector3(radius, -radius, 0)
                                    ]);
                        const mat = new THREE.MeshStandardMaterial({ color });
                        const mesh = new THREE.Mesh(geo, mat);
                        mesh.position.copy(camera.position);
                        scene.add(mesh);
                        const shape = new Ammo.btSphereShape(radius);
                        const transform = new Ammo.btTransform();
                        transform.setIdentity();
                        transform.setOrigin(new Ammo.btVector3(mesh.position.x, mesh.position.y, mesh.position.z));
                        const body = new Ammo.btRigidBody(
                            new Ammo.btRigidBodyConstructionInfo(mass, new Ammo.btDefaultMotionState(transform), shape)
                        );
                        const dir = camera.getWorldDirection(new THREE.Vector3());
                        if (weapon === 'prism') {
                            dir.x += (Math.random() - 0.5) * 0.2;
                            dir.y += (Math.random() - 0.5) * 0.2;
                            dir.z += (Math.random() - 0.5) * 0.2;
                            dir.normalize();
                        }
                        body.setLinearVelocity(new Ammo.btVector3(dir.x * speed, dir.y * speed, dir.z * speed));
                        world.addRigidBody(body);
                        objects.push({ mesh, body, type: 'projectile' });
                    }
                    gsap.to(camera.rotation, { x: '-=0.05', duration: 0.1, yoyo: true, repeat: 1 });
                }

                function getGroundPoint(event) {
                    const clientX = event.clientX || (event.touches && event.touches[0].clientX);
                    const clientY = event.clientY || (event.touches && event.touches[0].clientY);
                    if (!clientX || !clientY) return null;
                    const mouse = new THREE.Vector2(
                        (clientX / window.innerWidth) * 2 - 1,
                        -(clientY / window.innerHeight) * 2 + 1
                    );
                    const raycaster = new THREE.Raycaster();
                    raycaster.setFromCamera(mouse, camera);
                    const intersects = raycaster.intersectObjects(scene.children.filter(o => o.isMesh && o !== player.mesh));
                    return intersects.length ? intersects[0].point : null;
                }

                function updateWeapon() {
                    document.getElementById('weapon').textContent = `WEAPON: ${weapon.charAt(0).toUpperCase() + weapon.slice(1)}`;
                }

                function updatePlayer() {
                    const transform = player.body.getWorldTransform();
                    const pos = transform.getOrigin();
                    if (moveTarget) {
                        const dir = new THREE.Vector3(moveTarget.x - pos.x(), 0, moveTarget.z - pos.z());
                        dir.normalize().multiplyScalar(moveSpeed);
                        player.body.setLinearVelocity(new Ammo.btVector3(dir.x, player.body.getLinearVelocity().y(), dir.z));
                    }
                    camera.position.set(pos.x(), pos.y() + 1.5, pos.z());
                    if (pos.y() <= 2 && player.body.getLinearVelocity().y() <= 0) isJumping = false;
                }

                function handleCollisions() {
                    const dispatcher = world.getDispatcher();
                    const numManifolds = dispatcher.getNumManifolds();
                    for (let i = 0; i < numManifolds; i++) {
                        const manifold = dispatcher.getManifoldByIndexInternal(i);
                        const body0 = Ammo.castObject(manifold.getBody0(), Ammo.btRigidBody);
                        const body1 = Ammo.castObject(manifold.getBody1(), Ammo.btRigidBody);
                        const obj0 = objects.find(o => o.body === body0);
                        const obj1 = objects.find(o => o.body === body1);
                        if (obj0 && obj1 && ((obj0.type === 'projectile' && obj1.type === 'target') || (obj1.type === 'projectile' && obj0.type === 'target'))) {
                            const target = obj0.type === 'target' ? obj0 : obj1;
                            const now = performance.now();
                            if (now - lastHitTime < 1500) combo = Math.min(combo + 1, 5);
                            else combo = 1;
                            lastHitTime = now;
                            score += 10 * combo;
                            document.getElementById('score').textContent = `SCORE: ${score}`;
                            gsap.to(camera.position, {
                                x: `+=${(Math.random() - 0.5) * 0.2}`,
                                y: `+=${(Math.random() - 0.5) * 0.2}`,
                                z: `+=${(Math.random() - 0.5) * 0.2}`,
                                duration: 0.1,
                                yoyo: true,
                                repeat: 1
                            });
                            spawnShards(target);
                            scene.remove(target.mesh);
                            world.removeRigidBody(target.body);
                            objects = objects.filter(o => o !== target);
                        }
                    }
                }

                function spawnShards(target) {
                    for (let i = 0; i < 3; i++) {
                        const geo = new THREE.IcosahedronGeometry(0.3, 0);
                        const mat = new THREE.MeshStandardMaterial({ color: 0xff00ff });
                        const mesh = new THREE.Mesh(geo, mat);
                        mesh.position.copy(target.mesh.position);
                        scene.add(mesh);
                        const shape = new Ammo.btSphereShape(0.3);
                        const transform = new Ammo.btTransform();
                        transform.setIdentity();
                        transform.setOrigin(new Ammo.btVector3(mesh.position.x, mesh.position.y, mesh.position.z));
                        const body = new Ammo.btRigidBody(
                            new Ammo.btRigidBodyConstructionInfo(0.5, new Ammo.btDefaultMotionState(transform), shape)
                        );
                        body.setLinearVelocity(new Ammo.btVector3(
                            (Math.random() - 0.5) * 10,
                            (Math.random() - 0.5) * 10,
                            (Math.random() - 0.5) * 10
                        ));
                        world.addRigidBody(body);
                        objects.push({ mesh, body, type: 'shard' });
                    }
                }

                function animate() {
                    try {
                        requestAnimationFrame(animate);
                        world.stepSimulation(1 / 60, 10);
                        updatePlayer();
                        handleCollisions();
                        objects.forEach(obj => {
                            const transform = obj.body.getWorldTransform();
                            const pos = transform.getOrigin();
                            const quat = transform.getRotation();
                            obj.mesh.position.set(pos.x(), pos.y(), pos.z());
                            obj.mesh.quaternion.set(quat.x(), quat.y(), quat.z(), quat.w());
                            if (pos.y() < -10 || Math.hypot(pos.x(), pos.z()) > 100) {
                                scene.remove(obj.mesh);
                                world.removeRigidBody(obj.body);
                                objects = objects.filter(o => o !== obj);
                            }
                        });
                        renderer.render(scene, camera);
                    } catch (e) {
                        console.error('Render loop failed:', e);
                        showError('Render loop failed. Falling back to basic render.');
                        initFallback();
                    }
                }
            }).catch(err => {
                console.error('Ammo.js initialization failed:', err);
                showError('Physics engine failed. Showing basic render.');
                initFallback();
            });
        } else {
            console.warn('Ammo.js not loaded. Starting fallback render.');
            showError('Physics unavailable. Showing basic scene.');
            initFallback();
        }
    </script>
</body>
</html>
