/**
 * Minified by jsDelivr using Terser v5.15.1.
 * Original file: /npm/@pixi/filter-glow@5.2.1/dist/filter-glow.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
"use strict";
/*!
 * @pixi/filter-glow - v5.2.1
 * Compiled Fri, 24 Mar 2023 22:12:11 UTC
 *
 * @pixi/filter-glow is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */Object.defineProperty(exports,"__esModule",{value:!0});var r=require("@pixi/core"),g="attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}",f="varying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\n\nuniform float outerStrength;\nuniform float innerStrength;\n\nuniform vec4 glowColor;\n\nuniform vec4 filterArea;\nuniform vec4 filterClamp;\nuniform bool knockout;\nuniform float alpha;\n\nconst float PI = 3.14159265358979323846264;\n\nconst float DIST = __DIST__;\nconst float ANGLE_STEP_SIZE = min(__ANGLE_STEP_SIZE__, PI * 2.0);\nconst float ANGLE_STEP_NUM = ceil(PI * 2.0 / ANGLE_STEP_SIZE);\n\nconst float MAX_TOTAL_ALPHA = ANGLE_STEP_NUM * DIST * (DIST + 1.0) / 2.0;\n\nvoid main(void) {\n    vec2 px = vec2(1.0 / filterArea.x, 1.0 / filterArea.y);\n\n    float totalAlpha = 0.0;\n\n    vec2 direction;\n    vec2 displaced;\n    vec4 curColor;\n\n    for (float angle = 0.0; angle < PI * 2.0; angle += ANGLE_STEP_SIZE) {\n       direction = vec2(cos(angle), sin(angle)) * px;\n\n       for (float curDistance = 0.0; curDistance < DIST; curDistance++) {\n           displaced = clamp(vTextureCoord + direction * \n                   (curDistance + 1.0), filterClamp.xy, filterClamp.zw);\n\n           curColor = texture2D(uSampler, displaced);\n\n           totalAlpha += (DIST - curDistance) * curColor.a;\n       }\n    }\n    \n    curColor = texture2D(uSampler, vTextureCoord);\n\n    float alphaRatio = (totalAlpha / MAX_TOTAL_ALPHA);\n\n    float innerGlowAlpha = (1.0 - alphaRatio) * innerStrength * curColor.a;\n    float innerGlowStrength = min(1.0, innerGlowAlpha);\n    \n    vec4 innerColor = mix(curColor, glowColor, innerGlowStrength);\n\n    float outerGlowAlpha = alphaRatio * outerStrength * (1. - curColor.a);\n    float outerGlowStrength = min(1.0 - innerColor.a, outerGlowAlpha);\n\n    if (knockout) {\n      float resultAlpha = (outerGlowAlpha + innerGlowAlpha) * alpha;\n      gl_FragColor = vec4(glowColor.rgb * resultAlpha, resultAlpha);\n    }\n    else {\n      vec4 outerGlowColor = outerGlowStrength * glowColor.rgba * alpha;\n      gl_FragColor = innerColor + outerGlowColor;\n    }\n}\n";const e=class extends r.Filter{constructor(n){const o=Object.assign({},e.defaults,n),{outerStrength:r,innerStrength:t,color:l,knockout:a,quality:i,alpha:u}=o,c=Math.round(o.distance);super(g,f.replace(/__ANGLE_STEP_SIZE__/gi,`${(1/i/c).toFixed(7)}`).replace(/__DIST__/gi,`${c.toFixed(0)}.0`)),this.uniforms.glowColor=new Float32Array([0,0,0,1]),this.uniforms.alpha=1,Object.assign(this,{color:l,outerStrength:r,innerStrength:t,padding:c,knockout:a,alpha:u})}get color(){return r.utils.rgb2hex(this.uniforms.glowColor)}set color(n){r.utils.hex2rgb(n,this.uniforms.glowColor)}get outerStrength(){return this.uniforms.outerStrength}set outerStrength(n){this.uniforms.outerStrength=n}get innerStrength(){return this.uniforms.innerStrength}set innerStrength(n){this.uniforms.innerStrength=n}get knockout(){return this.uniforms.knockout}set knockout(n){this.uniforms.knockout=n}get alpha(){return this.uniforms.alpha}set alpha(n){this.uniforms.alpha=n}};let l=e;l.defaults={distance:10,outerStrength:4,innerStrength:0,color:16777215,quality:.1,knockout:!1,alpha:1},exports.GlowFilter=l;
//# sourceMappingURL=/sm/9e6a254d5724f2debbfce56f154809416d6fd2b82ddc4b6f0b3684d3e788921f.map